JAVA GC 主要对方法区和堆区进行垃圾回收。

常用常见算法：复制、标记-清除、标记-压缩

1、复制：复制算法采用的方式为从根集合进行扫描，将存活的对象移动到一块空闲的区域。 
当存活的对象较少时，复制算法会比较高效（新生代的Eden区就是采用这种算法），其带来的成本是需要一块额外的空闲空间和对象的移动。

2、该算法采用的方式是从跟集合开始扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，并进行清除。
标记-清除动作不需要移动对象，且仅对不存活的对象进行清理，在空间中存活对象较多的时候，效率较高，但由于只是清除，没有重新整理，因此会造成内存碎片。

3、该算法与标记-清除算法类似，都是先对存活的对象进行标记，但是在清除后会把活的对象向左端空闲空间移动，然后再更新其引用对象的指针，
由于进行了移动规整动作，该算法避免了标记-清除的碎片问题，但由于需要进行移动，因此成本也增加了。（该算法适用于旧生代）


垃圾回收器：
		1、串行收集器（Serial GC）
		    串行GC是最基本的、发展历史最悠久的收集器。单线程执行，简单高效使用复制算法。是新生代收收集器。
			它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。对象较大时，GC暂停时间长。
			
			
		2、并行GC收集器（Parallel）
			属于新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器（与ParNew收集器类似）。
			该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）
			
		3、CMS收集器
			阶段 1：Initial Mark（初始标记）
			阶段 2：Concurrent Mark（并发标记）
			阶段 3：Concurrent Preclean（并发预清理）
			阶段 4： Final Remark（最终标记）
			阶段 5： Concurrent Sweep（并发清除）
			阶段 6： Concurrent Reset（并发重置）
			特点：
			1）、CMS收集器的优点：并发收集、低停顿。
			2）、CMS收集器的缺点：  a、对CPU资源非常敏感。 
									b、无法处理浮动垃圾，可能出现Concurrent Model Failure失败而导致另一次Full GC的产生。
									c、因为采用标记-清除算法所以会存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次Full GC。
									
			适用于注重服务的响应速度，希望系统停顿时间最短，
			
		4、G1收集器
			阶段 1: Initial Mark（初始标记）
			阶段 2: Root Region Scan（Root区扫描）
			阶段 3: Concurrent Mark（并发标记）
			阶段 4: Remark（再次标记）
			阶段 5: Cleanup（清理）
			
			G1垃圾回收过程主要包括三个：
			1、纯年轻代模式转移暂停（Evacuation Pause: young）
			2、并发标记（Concurrent Marking）
			3、转移暂停: 混合模式（Evacuation Pause (mixed)）
			
			

			
			


